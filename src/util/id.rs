// Core CBC Casper
// Copyright (C) 2018 - 2020  Coordination Technology Ltd.
// Authors: pZ4 <pz4@protonmail.ch>,
//          Lederstrumpf,
//          h4sh3d <h4sh3d@truelevel.io>
//          roflolilolmao <q@truelevel.ch>
//
// This file is part of Core CBC Casper.
//
// Core CBC Casper is free software: you can redistribute it and/or modify it under the terms
// of the GNU Affero General Public License as published by the Free Software Foundation, either
// version 3 of the License, or (at your option) any later version.
//
// Core CBC Casper is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE. See the GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License along with the Core CBC
// Rust Library. If not, see <https://www.gnu.org/licenses/>.

/// Define how to serialize an arbitrary structure into as stream of bytes.  The
/// serialization can be performed with any standard or non-standard formats but
/// the **serialization MUST ensure that only one representation is valid.**
///
/// Define a content able to identifie its content with an ID. The structure
/// must be serializable with no malleability to ensure unique valid identifiers
/// for every unique valid content.
///
/// Define how to deserialize an arbitrary byte stream. **If the byte stream is
/// not the unique valid representation of the structure, deserialization MUST
/// fail.**
///
/// ## Serialization malleability
///
/// If a structure can be represented with multiple valid byte streams, then the
/// content identifier is not anymore unique. The implementation MUST ensure
/// only one unique valid representation. To ensure non-malleability we allow
/// deserialization to fail.
///
/// # Example
///
/// ```
/// extern crate bincode;
/// extern crate blake2;
/// extern crate itertools;
/// extern crate serde;
///
/// use core_cbc_casper::util::hash::Hash;
/// use core_cbc_casper::util::id::Id;
///
/// #[derive(serde_derive::Serialize, serde_derive::Deserialize, PartialEq, Debug)]
/// struct Example {
///     count: u64,
///     int: i64,
/// }
///
/// impl Id for Example {
///     type ID = Hash;
/// }
///
/// let example = Example { count: 10, int: -4 };
/// let serialized = example.serialize();
/// let deserialized = Example::deserialize(&serialized[..]);
/// assert_eq!(example, deserialized.unwrap());
/// ```
pub trait Id: serde::Serialize {
    // /// Define the type of the ID generated by `id`.
    type ID: From<[u8; 64]> + Ord;

    /// Define the hashing algorithm used to get content ID based on the
    /// serialization provided by the default `id` method.
    fn hash(data: &[u8]) -> Self::ID {
        use blake2::{Blake2b, Digest};
        let mut res = [0u8; 64];
        res.copy_from_slice(&Blake2b::digest(data));
        Self::ID::from(res)
    }

    fn serialize(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap()
    }

    fn deserialize<'z>(bin: &'z [u8]) -> Result<Self, bincode::Error>
    where
        Self: Sized + serde::Deserialize<'z>,
    {
        bincode::deserialize(bin)
    }

    /// The default method for getting the content ID is based on the
    /// serialization of the content.  This method can be overriden by other
    /// mechanisms such as random or counter IDs.
    fn id(&self) -> Self::ID {
        let ser = <Self as Id>::serialize(self);
        Self::hash(&ser[..])
    }
}
