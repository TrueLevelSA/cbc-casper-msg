// Core CBC Rust Library
// Copyright (C) 2018  pZ4 <pz4@protonmail.ch>,
//                     Lederstrumpf,
//                     h4sh3d <h4sh3d@truelevel.io>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

/// Define how to serialize an arbitrary structure into as stream of bytes.  The
/// serialization can be performed with any standard or non-standard formats but
/// the **serialization MUST ensure that only one representation is valid.**
///
/// Define a content able to identifie its content with an ID. The structure
/// must be serializable with no malleability to ensure unique valid identifiers
/// for every unique valid content.
///
/// Define how to deserialize an arbitrary byte stream. **If the byte stream is
/// not the unique valid representation of the structure, deserialization MUST
/// fail.**
///
/// ## Serialization malleability
///
/// If a structure can be represented with multiple valid byte streams, then the
/// content identifier is not anymore unique. The implementation MUST ensure
/// only one unique valid representation. To ensure non-malleability we allow
/// deserialization to fail.
pub trait Id: serde::Serialize {
    // /// Define the type of the ID generated by `getid`.
    type ID: From<[u8; 64]> + Ord;

    /// Define the hashing algorithm used to get content ID based on the
    /// serialization provided by the default `getid` method.
    fn hash(data: &[u8]) -> Self::ID {
        use blake2::{Blake2b, Digest};
        let mut res = [0u8; 64];
        res.copy_from_slice(&Blake2b::digest(data));
        Self::ID::from(res)
    }

    fn serialize(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap()
    }

    fn deserialize<'z>(bin: &'z [u8]) -> Result<Self, bincode::Error>
    where
        Self: Sized + serde::Deserialize<'z>,
    {
        bincode::deserialize(bin)
    }

    /// The default method for getting the content ID is based on the
    /// serialization of the content.  This method can be overriden by other
    /// mechanisms such as random or counter IDs.
    fn getid(&self) -> Self::ID {
        let ser = <Self as Id>::serialize(self);
        Self::hash(&ser[..])
    }
}
