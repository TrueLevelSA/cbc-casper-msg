// Core CBC Rust Library
// Copyright (C) 2018  pZ4 <pz4@protonmail.ch>,
//                     Lederstrumpf,
//                     h4sh3d <h4sh3d@truelevel.io>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

use std::fmt::Debug;
use std::hash::Hash;

use crate::justification::LatestMsgsHonest;
use crate::message;
use crate::util::weight::SendersWeight;

/// Describes an estimate, or a value of the consensus at a certain time
pub trait Estimate: Hash + Eq + Clone + Send + Sync + Debug + serde::Serialize {
    type M: message::Trait<Estimate = Self>;

    /// Choses an estimate from a set of latest messages
    /// The finalized_msg value can be used in order not to recursively
    /// go back to the genesis
    fn mk_estimate(
        latest_msgs: &LatestMsgsHonest<Self::M>,
        senders_weights: &SendersWeight<<<Self as Estimate>::M as message::Trait>::Sender>,
    ) -> Result<Self, &'static str>;
}

/// Define how to compare the trait type to zero
pub trait Zero<T: PartialEq> {
    const ZERO: T;

    /// returns whether or not the value is equal to zero
    fn is_zero(val: &T) -> bool {
        val == &Self::ZERO
    }
}

/// Define how to serialize an arbitrary structure into as stream of bytes.
/// The serialization can be performed with any standard or non-standard formats
/// but the **serialization MUST ensure that only one representation is valid.**
///
/// Define a content able to identifie its content with an ID. The structure must
/// be serializable with no malleability to ensure unique valid identifiers for
/// every unique valid content.
///
/// Define how to deserialize an arbitrary byte stream. **If the byte stream is not
/// the unique valid representation of the structure, deserialization MUST fail.**
///
/// ## Serialization malleability
///
/// If a structure can be represented with multiple valid byte streams, then the
/// content identifier is not anymore unique. The implementation MUST ensure only
/// one unique valid representation. To ensure non-malleability we allow deserialization
/// to fail.
pub trait Id: serde::Serialize {
    // /// Define the type of the ID generated by `getid`.
    type ID: From<[u8; 64]> + Ord;

    /// Define the hashing algorithm used to get content ID based on the serialization
    /// provided by the default `getid` method.
    fn hash(data: &[u8]) -> Self::ID {
        use blake2::{Blake2b, Digest};
        let mut res = [0u8; 64];
        res.copy_from_slice(&Blake2b::digest(data));
        Self::ID::from(res)
    }

    fn serialize(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap()
    }

    fn deserialize<'z>(bin: &'z [u8]) -> Result<Self, bincode::Error>
    where
        Self: Sized + serde::Deserialize<'z>,
    {
        bincode::deserialize(bin)
    }

    /// The default method for getting the content ID is based on the serialization of
    /// the content. This method can be overriden by other mechanisms such as random
    /// or counter IDs.
    fn getid(&self) -> Self::ID {
        let ser = <Self as Id>::serialize(self);
        Self::hash(&ser[..])
    }
}
